<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>therain2020</title><link>https://therain2020.github.io</link><description>the path to future</description><copyright>therain2020</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://therain2020.github.io</link></image><lastBuildDate>Sat, 10 May 2025 11:31:45 +0000</lastBuildDate><managingEditor>therain2020</managingEditor><ttl>60</ttl><webMaster>therain2020</webMaster><item><title>进程管理</title><link>https://therain2020.github.io/post/jin-cheng-guan-li.html</link><description># 1.进程、线程基础知识

## 1.1 进程


## 1.2 线程


## 1.3 调度

# 2.进程间有哪些通信方式

## 2.1 管道


## 2.2 消息队列


## 2.3 共享内存


## 2.4 信号量


## 2.5 信号


## 2.6 Socket


## 2.7 总结


# 3.多线程冲突了怎么办

## 3.1 竞争与协作


## 3.2 互斥与同步的实现和使用



## 3.3 经典同步问题



# 4.怎么避免死锁

## 4.1 死锁的概念


## 4.2 模拟死锁问题的产生

## 4.3 利用工具排查死锁问题


## 4.4 避免死锁问题的发生

## 4.5总结

# 5.什么是悲观锁、乐观锁

## 5.1 互斥锁与自旋锁

## 5.2 读写锁

## 5.3 乐观锁与悲观锁

## 5.4 总结

# 6.一个进程最多可以创建多少个线程

# 7.线程崩溃了，进程也会崩溃吗

## 7.1 线程崩溃，进程一定会崩溃吗

## 7.2 进程是如何崩溃的——信号机制

## 7.3 为什么线程崩溃不会导致JVM进程崩溃

## 7.4 openJDK 源码解析。</description><guid isPermaLink="true">https://therain2020.github.io/post/jin-cheng-guan-li.html</guid><pubDate>Sat, 10 May 2025 11:31:20 +0000</pubDate></item><item><title>Net——IP篇</title><link>https://therain2020.github.io/post/Net%E2%80%94%E2%80%94IP-pian.html</link><description># 1IP基础知识全家桶


## 1.1认识IP

IP位于TCP/IP参考模型中的第三层，网络层
网络层主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信
&gt; 网络层和数据链路层有什么关系
&gt; IP的负责在**没有直连**的两个网络之间进行通信传输，换句话说作用是在复杂的网络环境中，将数据包发送给最终目的主机
&gt; MAC的作用是实现**直连**的两个设备之间的通信
&gt; 在没有使用NAT网络的情况下，源IP和目标IP地址在传输过程中不会变化，只有源MAC地址和目标MAC一直变化。</description><guid isPermaLink="true">https://therain2020.github.io/post/Net%E2%80%94%E2%80%94IP-pian.html</guid><pubDate>Sat, 10 May 2025 11:19:04 +0000</pubDate></item><item><title>合肥大智慧二面</title><link>https://therain2020.github.io/post/he-fei-da-zhi-hui-er-mian.html</link><description>### 如何在一个文档中快速定位一个关键词
数据量小的情况下可以用字符串匹配

### 有哪些字符串匹配算法，怎么优化
KMP算法

### 如何在上亿个文档中快速定位一个关键词
可以用倒排索引


### ES分词错误的情况如何处理/es分词导致查询结果不准确
问题的具体描述是：索引里面有数据，却无法查询出来。</description><guid isPermaLink="true">https://therain2020.github.io/post/he-fei-da-zhi-hui-er-mian.html</guid><pubDate>Sat, 10 May 2025 06:36:16 +0000</pubDate></item><item><title>华资软件二面面经</title><link>https://therain2020.github.io/post/hua-zi-ruan-jian-er-mian-mian-jing.html</link><description>基础：
### 1.Mybatis中的#和$的区别
- 在处理 #{} 时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为 ? 号，在执行 SQL 时会为预编译 SQL 中的占位符（?）赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL 注入，提供更高的安全性，适合传递参数值。</description><guid isPermaLink="true">https://therain2020.github.io/post/hua-zi-ruan-jian-er-mian-mian-jing.html</guid><pubDate>Sat, 10 May 2025 06:33:58 +0000</pubDate></item><item><title>Redis持久化</title><link>https://therain2020.github.io/post/Redis-chi-jiu-hua.html</link><description># Redis持久化

## AOF持久化如何实现
整体流程：客户端发送写命令、Redis执行写操作命令（在内存中）、Redis记录写操作命令到日志（位于硬盘）
### 1.AOF日志
是什么：保存了Redis执行过的**写操作命令**的文本文件（不保存读操作命令，因为没意义）
查看：`cat`命令
先执行再保存的好处：①避免检查命令是否正确的开销②不会阻塞当前写操作命令的执行
先执行再保存的风险：①执行完未写入宕机导致丢失②可能阻塞下一个写操作命令的执行
综上，我们可以得出AOF日志写回硬盘的时机很重要，引出第二点——写回策略
### 2.三种写回策略
写入日志的细化流程：执行写操作命令、命令追加到`server.aof_buf`缓冲区、I/O系统调用`write()`、将`aof_buf`缓冲区数据拷贝到内核缓冲区`page cache`、内核发起写操作、写入硬盘
在`redis.conf`配置文件中的`appendfsync`配置项目中有以下3种参数可选：
&gt; Always，每次写操作命令执行完毕，同步将AOF日志数据写回硬盘
&gt; Everysec，每次写操作命令执行完毕，先将AOF命令写入AOF文件的内核缓冲区，然后每隔1s将缓冲区里的内容写回到硬盘
&gt; No，意味着不由Redis控制写回硬盘的时机，由操作系统决定何时将内核缓冲区内容写回硬盘
由于**主进程阻塞**和**减少数据丢失**是对立问题，这三个策略无法同时完美解决这两个问题。</description><guid isPermaLink="true">https://therain2020.github.io/post/Redis-chi-jiu-hua.html</guid><pubDate>Thu, 08 May 2025 08:12:46 +0000</pubDate></item><item><title>Redis相关面经</title><link>https://therain2020.github.io/post/Redis-xiang-guan-mian-jing.html</link><description>### Redis 常见数据类型和应用场景

常见的有五种：String、Hash、List、Set、Zset

新版本增加的：BitMap、HyperLogLog、GEO、Stream

### Redis为什么那么快？
1.是内存数据库，所有操作都在内存上进行
2.Redis实现的数据结构使得我们在对数据进行增删改查操作时，Redis能高效处理
（Redis实现的数据结构支持对数据进行高效的增删改查操作）

&gt; PS:
&gt; Redis数据结构并不是数据类型（String、List、Hash、Zset、Set），数据类型是Redis键值对中value的数据类型，即数据的保存形式。</description><guid isPermaLink="true">https://therain2020.github.io/post/Redis-xiang-guan-mian-jing.html</guid><pubDate>Thu, 08 May 2025 08:10:54 +0000</pubDate></item><item><title>模拟面试提示词</title><link>https://therain2020.github.io/post/mo-ni-mian-shi-ti-shi-ci.html</link><description>这里的提示词可以用于模拟面试，也可以用来回答面试问题。</description><guid isPermaLink="true">https://therain2020.github.io/post/mo-ni-mian-shi-ti-shi-ci.html</guid><pubDate>Thu, 08 May 2025 08:05:13 +0000</pubDate></item><item><title>HashMap相关面经整理</title><link>https://therain2020.github.io/post/HashMap-xiang-guan-mian-jing-zheng-li.html</link><description># 实现原理
## 一、从JDK 1.7 和 JDK 1.8 版本区别回答
- 在 JDK 1.7 版本之前，HashMap 数据结构是数组和链表，通过 **哈希算法** 将元素的Key 映射到数组中的槽位（Bucket）。</description><guid isPermaLink="true">https://therain2020.github.io/post/HashMap-xiang-guan-mian-jing-zheng-li.html</guid><pubDate>Mon, 05 May 2025 08:49:05 +0000</pubDate></item><item><title>个人项目连接</title><link>https://therain2020.github.io/post/ge-ren-xiang-mu-lian-jie.html</link><description>[前端练手项目](https://github.com/therain2020/Better-Vue3-Vite-application)。</description><guid isPermaLink="true">https://therain2020.github.io/post/ge-ren-xiang-mu-lian-jie.html</guid><pubDate>Tue, 29 Apr 2025 16:26:23 +0000</pubDate></item><item><title>Redission可重入、重试锁以及MultiLock原理</title><link>https://therain2020.github.io/post/Redission-ke-zhong-ru-%E3%80%81-zhong-shi-suo-yi-ji-MultiLock-yuan-li.html</link><description># Redisson的可重入锁（Reentrant Lock）是基于Redis实现的分布式锁。</description><guid isPermaLink="true">https://therain2020.github.io/post/Redission-ke-zhong-ru-%E3%80%81-zhong-shi-suo-yi-ji-MultiLock-yuan-li.html</guid><pubDate>Tue, 29 Apr 2025 02:37:24 +0000</pubDate></item><item><title>如何设计测试用例</title><link>https://therain2020.github.io/post/ru-he-she-ji-ce-shi-yong-li.html</link><description># 朋友圈的点赞功能，如何设计测试用例？

- 功能：正常使用和边界情况
- 性能：高并发情况下的使用
- 兼容：不同设备、操作系统、不同版本能否兼容
- 安全/权限：未登录无法查看，隐私安全等
- 界面：样式、颜色、排版等
- 网络：弱网使用，断网后数据同步
- 中断：来电、短信干扰等中断后能正确处理吗。</description><guid isPermaLink="true">https://therain2020.github.io/post/ru-he-she-ji-ce-shi-yong-li.html</guid><pubDate>Tue, 29 Apr 2025 02:08:57 +0000</pubDate></item><item><title>牛客上收集的测试面经（一）</title><link>https://therain2020.github.io/post/niu-ke-shang-shou-ji-de-ce-shi-mian-jing-%EF%BC%88-yi-%EF%BC%89.html</link><description> **1、get和post方法的区别？**
根据 RFC 规范：
```
GET 的语义是从服务器获取指定的资源
推理得到：GET 方法安全且幂等，因为GET只读，数据可以缓存在浏览器（保存为书签）/代理（nginx）中
``` 
```
POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同
推理得到：POST 因为会修改数据，所以不安全，因为重复请求会导致结果不一样，所以不是幂等的，综上POST请求不会被缓存，也不能保存为浏览器书签
``` 



**2、http和https的区别？**

协议：HTTP 即超文本传输协议，默认明文传输，不安全；HTTPS 在 TCP 和 HTTP 之间增加SSL/TLS 安全协议 加密传输 
握手：HTTP TCP 三次握手即可传输 ； HTTPS 增加 SSL/TLS 的握手
端口：HTTP 80 ；HTTPS 443
建议跳转 [小林](https://xiaolincoding.com/interview/linux.html#linux-%E5%91%BD%E4%BB%A4%E9%9D%A2%E8%AF%95%E9%A2%98)

**3、Linux常用命令？**

文件相关(mv mkdir cd ls)
进程相关( ps top netstate )
权限相关(chmod chown useradd groupadd)
网络相关(netstat ip addr)
测试相关(测试网络连通性:ping 测试端口连通性:telnet)

**4、Java中equals()方法和==的区别？**
对于字符串变量
```
'=='比较内存中的首地址 ； 'equals'比较字符串包含内容，因为Java中参数为string的equals是默认重写的
``` 


对于非字符串变量
```
如果没有重写equals方法，那么都是比较堆内存中的首地址
``` 

**5、Java中基本数据类型？**
8种
* 6种数值型：整数类型（byte、short、int、long）和浮点类型（float、double）
* 字符型：char
* 布尔型：boolean 

**6、Java多线程有哪些实现方式？**
思想 &gt; 代码
什么是：类似一心多用，一机多用
怎么实现
way1
```
1.定义一个类，继承Thread类，重写run方法（这个方法里面写线程的功能）。</description><guid isPermaLink="true">https://therain2020.github.io/post/niu-ke-shang-shou-ji-de-ce-shi-mian-jing-%EF%BC%88-yi-%EF%BC%89.html</guid><pubDate>Mon, 28 Apr 2025 14:07:40 +0000</pubDate></item><item><title>软件测试面经</title><link>https://therain2020.github.io/post/ruan-jian-ce-shi-mian-jing.html</link><description>### 测试工作是怎么进行的

&gt; [!NOTE]
&gt;  根据需求规格说明书做测试需求分析，制定测试计划（包括测试分组、测试模块分工、测试时间以及进度安排），组员按分工编写用例，用例编写完成进行审核，审核通过后按测试时用例和功能分工进行测试，测试时考虑浏览器是否兼容，发现bug则提交issue，并对bug进行跟踪直到缺陷可以接受，最后分析测试结果，撰写测试报告。</description><guid isPermaLink="true">https://therain2020.github.io/post/ruan-jian-ce-shi-mian-jing.html</guid><pubDate>Mon, 28 Apr 2025 12:36:18 +0000</pubDate></item><item><title>本地上传项目的最速流程</title><link>https://therain2020.github.io/post/ben-di-shang-chuan-xiang-mu-de-zui-su-liu-cheng.html</link><description>若本地已有项目，想将其上传到新的 GitHub 仓库，可按以下步骤操作：

### 1. 在 GitHub 创建新仓库
- 登录 GitHub 账号，点击右上角的 “+” 号，选择 “New repository”。</description><guid isPermaLink="true">https://therain2020.github.io/post/ben-di-shang-chuan-xiang-mu-de-zui-su-liu-cheng.html</guid><pubDate>Mon, 28 Apr 2025 07:56:54 +0000</pubDate></item><item><title>分布式事务框架：Seata</title><link>https://therain2020.github.io/post/fen-bu-shi-shi-wu-kuang-jia-%EF%BC%9ASeata.html</link><description># 基于Seata框架添加分布式事务

-  项目中很多功能都可以添加分布式事务。</description><guid isPermaLink="true">https://therain2020.github.io/post/fen-bu-shi-shi-wu-kuang-jia-%EF%BC%9ASeata.html</guid><pubDate>Fri, 25 Apr 2025 17:19:06 +0000</pubDate></item><item><title>一些要做的事情</title><link>https://therain2020.github.io/post/yi-xie-yao-zuo-de-shi-qing.html</link><description>1.项目话术：

- [校园快送](https://blog.csdn.net/qq_45195447/article/details/143307640)
- [诚通出行]()

2.信息概论答辩###4月28日上午

3.HSBC 面试预约

4.招商训练营

5.今天对自己的简历进行了大改，部分地方需要进行强化，尤其是①数据是否正确，怎么来的②相对陌生的技术。</description><guid isPermaLink="true">https://therain2020.github.io/post/yi-xie-yao-zuo-de-shi-qing.html</guid><pubDate>Fri, 25 Apr 2025 16:14:29 +0000</pubDate></item><item><title>项目架构</title><link>https://therain2020.github.io/post/xiang-mu-jia-gou.html</link><description># 基于Github三件套设计一个分层架构方案，涵盖内容管理、自动化流程和功能扩展性：

```Text
AIGmeek/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── aigmeek/
│   │   │           ├── config/                # 配置中心（Spring Boot标准）
│   │   │           │   ├── GitHubConfig.java   # OAuth认证配置 
│   │   │           │   └── TemplateConfig.java  # 模板引擎配置 
│   │   │           ├── core/
│   │   │           │   ├── generator/        # 静态生成器（替代Python脚本）
│   │   │           │   │   ├── HtmlGenerator.java  
│   │   │           │   │   └── SitemapBuilder.java  
│   │   │           │   └── processor/       # 内容处理器 
│   │   │           │       ├── IssueParser.java  
│   │   │           │       └── MarkdownConverter.java  
│   │   │           ├── github/               # API交互层 
│   │   │           │   ├── client/
│   │   │           │   │   ├── IssueClient.java   # 实现PyGithub功能 
│   │   │           │   │   └── RepoClient.java  
│   │   │           │   └── model/            # 数据模型（Record类型）
│   │   │           │       └── GIssue.java  
│   │   │           └── web/
│   │   │               └── controller/       # 预览功能API端点 
│   │   │                   └── PreviewController.java  
│   │   └── resources/
│   │       ├── static/                      # 全量保留原前端资源 
│   │       │   ├── css/
│   │       │   │   ├── style.css            # 增强响应式布局 
│   │       │   │   └── dark-mode.css        # 支持2025新CSS特性 
│   │       │   ├── js/
│   │       │   │   ├── plugins/           # 插件体系（热加载）
│   │       │   │   │   ├── lightbox.js     # 图片灯箱优化版 
│   │       │   │   │   └── vercount.js     # 访问统计模块 
│   │       │   │   └── GmeekTOC.js         # 目录生成器 
│   │       │   └── img/                   # 静态资源托管 
│   │       └── templates/                 # Thymeleaf模板 
│   │           ├── fragments/             # 模块化组件 
│   │           │   ├── header.html  
│   │           │   └── comment.html        # 集成utteranc评论 
│   │           ├── post.html               # 文章页（支持SEO优化）
│   │           └── index.html              # 首页（分页逻辑）
│   └── test/                              # 测试套件 
│       └── java/
│           └── com/
│               └── aigmeek/
│                   └── core/
│                       └── generator/      # 生成器单元测试 
├── .github/                               # 自动化流水线 
│   └── workflows/
│       └── gh-pages.yml                   # 深度优化的Java构建流程 
└── HELP.md                                # 新版文档（含AI助手指引）
```

## 一、核心架构分层

### 1.数据获取层

使用Github API Client for Java实现Issue数据抓取
```Java
public class IssueFetcher {
    // 实现基于标签过滤的Issue查询（对应MD文档的标签要求）
    public List&lt;IssueDTO&gt; fetchIssuesByLabel(String repo, String label);
    // 解析Issue正文中的Markdown和元数据（参考post.html 模板）
    public PostContent parseIssueBody(String markdownContent);
}
```

### 2.静态生成层

采用Thymeleaf模板引擎替代Jinja2
```Java
@Component 
public class StaticGenerator {
    // 生成文章页（集成lightbox.js 图片预览功能[13]()）
    public void generatePostPage(PostContent post, Path outputDir);
    // 生成索引页（实现plist.html 的分页逻辑[1]()）
    public void generateIndexPage(List&lt;PostContent&gt; posts, int pageNum); 
}
```

### 3.自动化部署层

集成Github Actions的Java实现方案
```Yaml
# .github/workflows/build.yml  核心配置 
- name: Build with Maven 
  run: mvn -B package --file pom.xml  
- name: Deploy to Pages 
  uses: peaceiris/actions-gh-pages@v3 
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
    publish_dir: ./target/generated-site 
```

## 二、关键组件设计

### 1.配置中心

```Java
@Configuration 
public class BlogConfig {
    // 读取类似config.json 的配置（参考requirements.txt 依赖管理[3]()）
    @Value('${blog.baseUrl}')  
    private String baseUrl;
    
    // 集成utteranc评论系统（对应post.html 的评论区块[9]()）
    @Bean 
    public CommentService commentService() {
        return new UtterancCommentImpl();
    }
}
```

### 2.前端资源管理

保留原JS插件体系的集成方式：
```Java
public class AssetManager {
    // 将GmeekTocBot.js 等插件写入生成目录 
    public void copyPluginFiles(Path outputDir) {
        Files.copy('src/main/resources/static/GmeekTOC.js',  
                   outputDir.resolve('js/GmeekTOC.js')); 
    }
}
```

### 3.元数据处理器
```Java
public class MetadataExtractor {
    // 实现类似plist.html 的标签处理逻辑[1]()
    public List&lt;String&gt; extractLabels(JSONObject issueJson) {
        return Arrays.stream(issueJson.getJSONArray('labels')) 
                     .map(label -&gt; label.getString('name')) 
                     .collect(Collectors.toList()); 
    }
}
```

## 三、技术选型建议

![Image](https://github.com/user-attachments/assets/11dd2349-6f0b-4347-9b56-40423140a521)

## 四、典型工作流程

### 1.Issue创建/更新事件触发
```Mermaid
sequenceDiagram 
    Github Issues-&gt;&gt;Java服务: Webhook通知 
    Java服务-&gt;&gt;Github API: 获取Issue详情[2]()
    Github API-&gt;&gt;Java服务: 返回JSON数据 
    Java服务-&gt;&gt;StaticGenerator: 生成HTML（集成footer.html[6]() ）
    StaticGenerator-&gt;&gt;Github Pages: 提交到gh-pages分支 
```


### 2.构建部署流程
```Bash
# 通过Actions实现CI/CD[10]()
mvn clean package 
&amp;&amp; java -jar blog-generator.jar  
&amp;&amp; gh-pages -d target/generated-site 
```

## 五、扩展性设计

### 1.插件机制
```Java
public interface BlogPlugin {
    void apply(PostContent post, TemplateContext context);
}
// 实现类似GmeekVercount的访问统计[5]()
@Component 
public class VisitCounterPlugin implements BlogPlugin {
    public void apply(PostContent post, TemplateContext ctx) {
        ctx.addScript('&lt;script  src='/js/GmeekVercount.js'&gt;&lt;/script&gt;'); 
    }
}
```

### 2.多仓库支持
通过@ConfigurationProperties实现多源配置：
```Java
@ConfigurationProperties(prefix = 'github')
public class RepoConfig {
    private Map&lt;String, RepoProfile&gt; repositories;
    // 支持同时管理多个Github Pages站点 
}
```


ps：看到Gmeek的第一眼我就忘本了，我也想做一个这玩意。</description><guid isPermaLink="true">https://therain2020.github.io/post/xiang-mu-jia-gou.html</guid><pubDate>Tue, 22 Apr 2025 14:01:23 +0000</pubDate></item><item><title>Linux和Windows 在内核上的区别</title><link>https://therain2020.github.io/post/Linux-he-Windows%20-zai-nei-he-shang-de-qu-bie.html</link><description># Linux和Windows 在内核上的区别 
## 什么是内核
## 内核的作用
## 内核如何工作
## Linux如何设计内核
## Windows如何设计内核。</description><guid isPermaLink="true">https://therain2020.github.io/post/Linux-he-Windows%20-zai-nei-he-shang-de-qu-bie.html</guid><pubDate>Tue, 22 Apr 2025 07:03:43 +0000</pubDate></item></channel></rss>