基础：
### 1.Mybatis中的#和$的区别
- 在处理 #{} 时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为 ? 号，在执行 SQL 时会为预编译 SQL 中的占位符（?）赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL 注入，提供更高的安全性，适合传递参数值。
- 在处理 ${} 时，只是创建普通的 SQL 语句，然后在执行 SQL 语句时 MyBatis 将参数直接拼入到 SQL 里，不能防止 SQL 注入，因为参数直接拼接到 SQL 语句中，如果参数未经过验证、过滤，可能会导致安全问题。


### 2.Java命名：
类名，大驼峰，首字母大写，名字开头，避免缩写。
方法名，小驼峰，首字母小写，动词开头，描述动作。
变量名，小驼峰，首字母小写，名词开头，避免单字符。
常量，全大写+下划线
枚举，全大写

### 3.设计多对多的实体数据库表
多对多，三张表，联合主键的关系表加外键
比如学生和课程之间的多对多关系
student 主键id+各种信息字段
course  主键id+各种信息字段
student_course student_id+course_id，（student_id和course_id作为联合主键）+（student_id作为外键关联student表，course也一样）

### 4.设计一对多的实体数据库表
一对多，两张表，多的表加外键（在一对多的关系中，存在两张表（一张父表一张子表），父表的一条数据对应子表的多条数据，那么子表（多）就需要添加上父表（一）的外键字段）
部门和员工之间的1：n关系
department： id + name + location等
employee：	id + name + dept_id（外键）

### 4.5 一对一呢？
一对一和一对多语法上并没有什么太大区别，只是在外键处加了一个唯一性约束；

### 5.select从两张表（表1两行数据，表2三行数据）中查询，但是缺少where关键词，会查询到几行数据，为什么
2*3=6行
默认执行笛卡尔积，即两表所有行的组合

### 6.常见的排序算法
[这部分小林code数据结构与算法面试篇讲的很好](https://xiaolincoding.com/interview/data.html#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)

### 7.冒泡排序为什么叫做冒泡排序
通过相邻元素的比较和交换，每次将最大（或最小）的元素逐步“冒泡”到最后（或最前）